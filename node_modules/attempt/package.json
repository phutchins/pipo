{
  "author": {
    "name": "Tom Frost",
    "email": "tom@frosteddesign.com"
  },
  "name": "attempt",
  "description": "Automatically retry functions that fail, in crazily customizable ways.",
  "version": "1.0.1",
  "homepage": "https://github.com/TomFrost/node-attempt",
  "repository": {
    "type": "git",
    "url": "git://github.com/TomFrost/node-attempt.git"
  },
  "main": "lib/attempt.js",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha -R spec -s 150 test"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": ">= 1.1.0",
    "should": ">= 0.6.3"
  },
  "readme": "# Attempt [![Build Status](https://secure.travis-ci.org/TomFrost/node-attempt.png?branch=master)](http://travis-ci.org/TomFrost/node-attempt) [![Code Climate](https://codeclimate.com/github/TomFrost/node-attempt/badges/gpa.svg)](https://codeclimate.com/github/TomFrost/node-attempt)\nRetries functions that throw or call back with an error, in crazily\ncustomizable ways.\n\n## Installation\nIn your project folder, type:\n\n\tnpm install attempt\n\n## Usage\nWhenever you have code that looks like this:\n\n\tfunction flakyApiCall(function(err, result) {\n\t    if (err)\n\t        console.log('Flaky API died AGAIN!', err);\n\t    else\n\t        doSomething(result);\n\t});\n\nJust drop that code in an attempt!\n\n\tvar attempt = require('attempt');\n\tattempt(\n\t\tfunction() {\n\t\t\tflakyApiCall(this);\n\t\t},\n\t\tfunction(err, result) {\n\t        if (err)\n\t            console.log('Flaky API failed 3 times.', err);\n\t        else\n\t            doSomething(result);\n\t    });\n\n## Details\nAttempt will re-run your attempted function if it throws an error or if it\ncalls back with a non-falsey first argument (following the first-arg-is-an-error\nstandard Node.js convention).  The function call looks like this:\n\n**attempt([options], tryFunc, [callback])**\n\ntryFunc is called with one argument: attempts.  It is the number of times the\ntryFunc has been run before.\n\n\tattempt(function(attempts) {\n\t\tif (attempts)\n\t\t\tconsole.log('This is retry #' + attempts);\n\t\telse\n\t\t\tconsole.log('This is the first attempt!');\n\t});\n\n### Options\nThe following options are set per request:\n\n#### retries\n*Default: 2.* The number of times to retry the tryFunc before giving up and sending the error to the callback.\n\n\tattempt(\n\t\t{ retries: 15 },\n\t\tfunction() {\n\t\t\tflakyApiCall(this);\n\t\t},\n\t\tfunction(err, result) {\n\t\t\tif (err)\n\t\t\t\tconsole.log('Failed first attempt + 15 retries = 16 failures.', err);\n\t\t\telse\n\t\t\t\tdoSomething(result);\n\t\t});\n\n#### interval\n*Default: 0.* The number of milliseconds to wait between attempts.\n\n\tattempt(\n\t\t{ interval: 5000 },\n\t\tfunction() {\n\t        flakyApiCall(this);\n\t    },\n\t    function(err, result) {\n\t        if (err)\n\t            console.log('3 attempts * 5 seconds = 15 seconds of failure.', err);\n\t        else\n\t            doSomething(result);\n\t    });\n\n#### factor\n*Default: 1.* The factor by which the interval should be multiplied per\nattempt.  If set to 2 with an interval of 5000, the first retry will execute\nafter 5 seconds, the second after 10, the third after 20, and so on.\n\nThis allows an exponential back-off scheme.  For a smaller gap between retries,\nfloats like 1.2 can be used to grow the interval at a slower rate.\n\n#### onError\n*Default: null.* Function to call when the tryFunc fails with an error.  The\nfirst argument is the error.\n\n\tattempt(\n\t\t{\n\t\t\tonError: function(err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t},\n\t\tfunction() { flakyApiCall(this); },\n\t\tfunction(err, result) { /* ... */ });\n\nThe second argument, if it exists, is a callback function that will need to be\ncalled in order for the next attempt to continue.  This is useful if you have\nto do something asynchronous to fix the error.\n\n\tattempt(\n\t\t{\n\t\t\tonError: function(err, done) {\n        \t\tlog.write(err, done);\n        \t}\n        },\n        function() { flakyApiCall(this); },\n\t\tfunction(err, result) { /* ... */ });\n\nBy default, calling done() will ignore the retry interval.  If you still want\nit to be observed, call *done(true)*.\n\n#### max\n*Default: Infinity.* The maximum number of milliseconds to wait before retrying.\nIf the interval or factor causes a wait time larger than 'max', 'max' will\nbe used.\n\n#### random\n*Default: 0.* Increase the wait interval by a random factor. Generally, this\nshould be a number between 0 (no randomness) and 1 (wait time could double).\nFor example, if .5 is used, the interval could be anywhere between 100% and\n150% of its original calculated time.\n\n#### attempts\n*Default: 0.* The number of attempts to fake Attempt into believing were\nalready completed.  This is mostly used by Attempt internally, but can be\nuseful for hacking interval times.\n\n## License\nAttempt is distributed under the MIT license.\n\n## Credits\nAttempt was created by Tom Frost in 2012.  Because webservice APIs be flaky,\nman.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/TomFrost/node-attempt/issues"
  },
  "_id": "attempt@1.0.1",
  "_shasum": "be7d752dee25f67e5816e82c1600f7edc45de300",
  "_from": "attempt@",
  "_resolved": "https://registry.npmjs.org/attempt/-/attempt-1.0.1.tgz"
}
